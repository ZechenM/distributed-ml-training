#!/bin/bash

# This script is generated by chat.deepseek.com
# Orchestration: Start the server, and start three workers at the same time

alias python=python3

python --version > /dev/null 2>&1

if [ $? -ne 0 ]; then
    echo "python not found"
    exit 1
fi


# Check if any .pkl files exist
if ls *.pkl > /dev/null 2>&1; then
    echo ".pkl files found."
else
    echo "No .pkl files found. Generating necessary pre-train data"
    python ./prepare_data.py
    echo "pre-training data generated, please re-run current script"
    exit 1  # Exit with a non-zero status to indicate no .pkl files were found
fi


### env pre-check complete, start the server, then start workers.

# Define log file paths
SERVER_LOG="./logs/server_log.txt"
WORKER0_LOG="./logs/worker_log0.txt"
WORKER1_LOG="./logs/worker_log1.txt"
WORKER2_LOG="./logs/worker_log2.txt"

# Create the logs directory if it doesn't exist
mkdir -p ./logs

# Start the server and redirect output to SERVER_LOG
python -u ./server.py > "$SERVER_LOG" 2>&1 &  # run python with -u (unbuffered mode)

# Get the process ID of the server
SERVER_PID=$!
echo "server PID $SERVER_PID"

# Function to kill the server process on exit 
cleanup() {
    echo "Cleaning up server process (PID: $SERVER_PID)..."
    kill -9 "$SERVER_PID" 2>/dev/null
}

# Set up trap to call cleanup on script exit (non-zero status)
trap cleanup EXIT

# Wait for the server to start and monitor the log file
TIMEOUT=100  # Maximum time to wait in seconds
START_TIME=$(date +%s)
FOUND_MESSAGE=false

while true; do
    # Check if the server process is still running
    if ! ps -p $SERVER_PID > /dev/null; then
        echo "Server process failed or exited unexpectedly."
        exit 1
    fi

    # Check the log file for the expected message
    if grep -q "Server listening ..." "$SERVER_LOG"; then
        # Count the number of occurrences of the message
        COUNT=$(grep -c "Server listening ..." "$SERVER_LOG")
        if [ $COUNT -eq 1 ]; then
            FOUND_MESSAGE=true
            break
        else
            echo "Unexpected number of 'Server listening ...' messages found."
            exit 1
        fi
    fi

    # Check if the timeout has been reached
    CURRENT_TIME=$(date +%s)
    ELAPSED_TIME=$((CURRENT_TIME - START_TIME))
    if [ $ELAPSED_TIME -ge $TIMEOUT ]; then
        echo "Timeout reached. Server did not start successfully."
        exit 1
    fi

    # Wait for a short period before checking again
    sleep 1
done

sleep 10

# If the message was found, proceed
if $FOUND_MESSAGE; then
    echo "Server started successfully. Proceeding..."

    python -u ./worker.py 0 > "$WORKER0_LOG" 2>&1 &
    python -u ./worker.py 1 > "$WORKER1_LOG" 2>&1 &
    python -u ./worker.py 2 > "$WORKER2_LOG" 2>&1 &
else
    echo "Server did not start successfully."
    exit 1
fi


while true; do
    # never self-terminate to keep server running
    sleep 1  # Optional: Add a delay to avoid flooding the terminal
done